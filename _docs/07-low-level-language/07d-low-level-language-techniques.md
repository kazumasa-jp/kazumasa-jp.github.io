---
title: 低水準言語の技術
permalink: /docs/low-level-language-techniques-d/
tags: [Z80, Assembly Language, BCD]
description: Some notes about binary to BCD conversion
toc: true
---

## バイナリ値をBCDに変換する(2)

プログラムの詳細に入る前にアルゴリズムの概要を説明する。

### アルゴリズムの概要

最初にレジスタBの値(0〜99:0x00〜0x63)を10で割ったときの剰余を求める。Z80は除算命令を持たないため、ビット演算を使用して8で割ったときの剰余を求め、これを補正して10での剰余を求める。8で割ったときの剰余を10で割ったときの剰余に変換するための補正量を下表に示す。

| 入力(10進) | 10で割ったときの剰余 | 8で割ったときの剰余 | 補正量 |
|------------|----------------------|---------------------|--------|
| 0〜7       | 0〜7                 | 0〜7                |      0 |
| 8〜15      | 8〜5                 | 0〜7                |     -2 |
| 16〜23     | 6〜3                 | 0〜7                |     -4 |
| 24〜31     | 4〜1                 | 0〜7                |     -6 |
| 32〜39     | 2〜9                 | 0〜7                |     -8 |
| 40〜47     | 0〜7                 | 0〜7                |      0 |
| ...        | ...                  | ...                 |    ... |
| 96〜99     | 6〜9                 | 0〜3                |     -4 |

つまり、入力を8で割った数(入力の上位5ビット)の2倍を計算し、それを10で割ったときの剰余が補正量になる。

Z80は、加減算後にDAA命令を使えば、直前の演算がBCD表記の数値同士の演算であった場合の結果に変換することができる(例えば、0x19と0x21の加算結果は0x3aとなるが、この演算の直後にDAA命令を実行すれば、0x40が得られる)。BCD表記の下位ニブルを取れば10で割った余りを求めることができる。

商の計算は入力から剰余を引いて10で割ればよい。これを次のように計算する。

入力から余りを引いた結果をHと置き、商をKとすると、K=H/10=H/(8+2)と書ける。
これから、入力を10で割ったときの商Kは、

```
(8+2)*K=H
 → 2*K=H-8*K
 → K=H/2-4*K
     =H/2-4*(H/2-K*4)
     =H/2-2*H+16*K
     =-H/2-H
```

として求めることができる。

### 実装例

ソースコードは下記のようになる。
```
;; 剰余を求める
    LD A,B
    RRCA
    RRCA
    RRCA        ;; (1) A=B/8(上位5ビット)
    DAA         ;; (2) AをBCDに変換する
    ADD A,A     ;; (3) A=A*2(通常のバイナリ演算)
    DAA         ;; (4) BCDに修正(A=B/4)
    LD C,A
    LD A,B
    AND 07H     ;; (5) 下位3ビット(8で割ったときの剰余)を取り出す。
    SUB A,C     ;; (6) 剰余を補正する
    DAA         ;; (7) BCDに修正する。
    AND 0FH     ;; (8) 下位一桁(10進表記)を取り出せば剰余が求まる。
;; 商を求める
    LD C,A
    SUB A,B     ;; (9) A=-H(10の倍数)
    LD H,A
    RRCA        ;; (10) A=-H/2
    ADD A,H     ;; (11) A=-H/2-H
    AND 0FH     ;; (12) 下位ニブルを取り出し、商とする
    LD H,A
    LD A,C
    RET
```
このプログラムで難しいのは、1度目のDAAの動作だろう((2))。

入力は0〜99、16進数で0x00〜0x63、2進数で0b0000_0000〜0b0110_0011なので、(1)の時点でAが取りうる値は、2進数で0b0000_1100、16進数で0x0C、10進数で12以下になっている。

次に実行するDAA命令の動作を表に示す。DAA命令は、通常、直前に実行した加算や減算命令がBCD表記のデータに対して行われたものになるように結果を補正する。ただ、今回は回転命令後に実行されるため、下記の表から動作を読み解く。

|           | C Flag | HEX value in | H Flag | HEX value in |  Number | C flag |
| Operation | Before |  upper digit | Before |  lower digit |   added |  After |
|           |    DAA |    (bit 7-4) |    DAA |    (bit 3-0) | to byte |    DAA |
|-----------|--------|--------------|--------|--------------|---------|--------|
|           |      0 |          0-9 |      0 |          0-9 |      00 |      0 |
| ADD       |      0 |          0-8 |      0 |          A-F |      06 |      0 |
|           |      0 |          0-9 |      1 |          0-3 |      06 |      0 |
| ADC       |      0 |          A-F |      0 |          0-9 |      60 |      1 |
|           |      0 |          9-F |      0 |          A-F |      66 |      1 |
| INC       |      0 |          A-F |      1 |          0-3 |      66 |      1 |
|           |      1 |          0-2 |      0 |          0-9 |      60 |      1 |
|           |      1 |          0-2 |      0 |          A-F |      66 |      1 |
|           |      1 |          0-3 |      1 |          0-3 |      66 |      1 |
|-----------|--------|--------------|--------|--------------|---------|--------|
| SUB       |      0 |          0-9 |      0 |          0-9 |      00 |      0 |
| SBC       |      0 |          0-8 |      1 |          6-F |      FA |      0 |
| DEC       |      1 |          7-F |      0 |          0-9 |      A0 |      1 |
| NEG       |      1 |          6-F |      1 |          6-F |      9A |      1 |

DAA命令実行時の上位ニブルは0、下位ニブルは0-C、Hフラグは0である。この条件に合致する部分を表から抜き出すと下の表のようになっている。

| C Flag | HEX value in | H Flag | HEX value in |  Number | C flag |
| Before |  upper digit | Before | lower digit  |   added |  After |
|    DAA |    (bit 7-4) |    DAA | (bit 3-0)    | to byte |    DAA |
|--------|--------------|--------|--------------|---------|--------|
|      0 |          0-9 |      0 | 0-9          |      00 |      0 |
|      0 |          0-8 |      0 | A-F          |      06 |      0 |
|      1 |          0-2 |      0 | 0-9          |      60 |      1 |
|      1 |          0-2 |      0 | A-F          |      66 |      1 |

Cフラグが立っていないときはレジスタの値がBCD表記に変換される。Cフラグが立っているときはBCDコードの上位ニブルに6(0b0110)が加算された状態になる。

ここから先は条件を分けて考えよう。

(1)の実行後にキャリーフラグが立っていなかった場合のほうが簡単なので、こちらを先に見てみる。(2)のDAA命令はAレジスタの値をBCD表記に変換する。(3)ではAを2倍し、(4)で結果をBCDへ変換する。この時点でAレジスタの値は入力(Bレジスタ)を1/4した値になっている。

(1)の実行後にキャリーフラグが立っていた場合、DAA命令実行後のAの値は、(M+6)×16+Nとなっている。これを2倍すると(2M+12)×16+2Nとなる。M=0または1、0<=N<=9であることを考えると、この値は255を超えることはないため、Cフラグは0、上位ニブルは12以上になることがわかる。

その結果、次のDAA命令では、0x60または0x66が加算されるため、上位ニブル(2M+12)に含まれる12はニブルの外に桁上げされて見えなくなり、この場合も、(4)が終わった時点で、Aレジスタには入力の1/4が入ることになる。
