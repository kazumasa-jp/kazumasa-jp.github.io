---
title: 低水準言語の技術
permalink: /docs/low-level-language-techniques-e/
tags: [Z80, Assembly Language, BCD]
description: Some notes about binary to BCD conversion
toc: true
---

## バイナリ値をBCDに変換する(3)

今度は10で割った商を先に求めるが、被除数を10で割る代わりに0.1を掛ける。ただし、使用する演算を加算とビットシフトで済ませるために51/512を掛けることにする。

ところが、51/512は0.1より若干小さい。したがって、10*51/512<10、90*51/512<90となるので、被除数が10の倍数のとき(0のときは除く)、正しい値が求められない。

そこで51/512×被除数+αとして補正を行う。一番大きなαが必要になるのは、被除数が90のときである。したがってαは
```
51/512×90+α>=9
α>=9-51/512×90=9×(512-510)/512=18/512
```
を満たす必要が有る。

51/512=(16+1)×3/512=(1+1/16)×3/32となるから、
(1) 被除数を1/16した値を求める
(2) 1)の量を3倍する
(3) 32で割る
という方法で商を求めることができる。

2)で3倍した後に補正すると、18/512=(18/16)/32<2/32より、補正量として2を加えればよいし、(1)の後に補正するなら、18/512=(6/16)/3/32<1/3/32より、補正量として1を加えればよい。

ただ、加算命令(ADD)は2バイト長の命令で7クロックかかるが、インクリメント命令(INC)は4クロックで済む。必要なメモリもADDは2バイト、INCなら1バイトで良い。これらを考慮すると1)の後に補正したほうが良い。

1)の後に補正をすると、最終的に3×16/512=48/512が加算されることになるが、これは1を越さないので補正量が大きすぎることはない。
```
;;
;; 商を求める
;; 
;; 1/10≒51/512として商を求める
;;
    LD A,B
    RRCA
    RRCA
    RRCA
    RRCA     ;; (1) A=1/16*B
    AND 0FH  ;; 上位4ビットを取得
    INC A    ;; A=1/16*B+1(補正)
    ADD A,B  ;; (2) A=17/16*B+1
    LD C,A
    ADD A,C  ;;     A=34/16*B+2
    ADD A,C  ;;     A=51/16*B+3
    RLA      ;; (3) 左に4ビット回転(with Carry)
    RLA      ;;     →右に5ビットシフト(/32)
    RLA      ;;       A=51/512*B+3/32
    RLA      ;;
    AND 0FH  ;; (4) A: 商
;;
;; 剰余を求める
;;
;; Bから商×10を引く
;;
    LD H,A
    ADD A,A  ;;
    ADD A,A  ;;
    ADD A,H  ;; (5) A=A*5
    CPL      ;; (6) ビット反転
    RLCA     ;; (7) A=-10*B (MSB=1がLSBに入るので、2の補数になる)
    ADC A,B  ;; (8) B: 剰余
```
剰余については被除数から商の10倍を引くことで求める。

(5)までで商を5倍している。(6)、(7)でこの結果を-2倍しているのだが、ここは少し説明が必要かもしれない。

(5)を実行した時点ではAは45以下なので、(6)でCPL命令を使ってビット反転した後は、上位の2ビットは必ず0b11になっている。これをRLCA命令で左に1ビット回転してやれば、最上位ビットの1が最下位ビットに入るので、商の10倍の2の補数が得られる。

素直に商の10倍を計算して2の補数を取ると、加算命令(ADD)1回、2の補数命令(NEG)1回が必要になる。NEG命令よりもCPL命令のほうが早く、命令長も短いので、CPL+RLCAの組み合わせを選ぶほうが良い。

