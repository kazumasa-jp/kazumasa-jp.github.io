---
title: 低水準言語の技術
permalink: /docs/low-level-language-techniques-h/
tags: [Z80, Assembly Language, BCD]
description: Some notes about binary to BCD conversion
toc: true
---

## バイナリ値をBCDに変換する(6)


今回は1より若干大きな数(13/128)をかけて商を求める。
13/128=0.1015625なので、13/128×Bで商を計算すると1.5625%の誤差が出る。この誤差が商に影響を与える影響を調べよう。

Bの10の位をM、1の位をNとすると、
```
  M <= 13/128*(10*M+N) < M + 1
  →0<=2*M+13*N<128
```
となる条件であれば、正しい商が求められる。

まず、左辺は任意のM>=0、N>=0で成り立つのでこちらは考えなくてよい。

右辺のほうは、0<=N<=8のとき、任意のMについて上式が成り立ち、N=9のときはM>=6で成り立たないことがわかる。

そこで、N'→N-1(1<=N<=9)という補正を行ったときに、任意のMについて正しい商が求められるかどうか確認する。
正しい商が求められる条件は、
```
  M <= 13/128*(10*M+N-1) < M + 1
  → 13 <= 2*M+13*N < 141
```
M>=0なので、左辺はN>=1であれば満足できる。

右辺は13×N<141-2×9=133→N<133/13であれば成り立つので、こちらもN<=9であれば問題はない。つまりN>0のときはN->N-1という補正を行えば正しい商が求められる。

まとめると、
(1) 0<=N<=8のとき、補正をしなくても正しい商が求められる。
(2) N>=1のとき、任意のMについてN→N-1という補正を行えば、正しい商を求めることができる。
この２つを同時に実現するためには、Bの最下位ビットを0にしてから演算を行えば良い。
```
;;
;; 商を求める
;;
    LD A,B   ;;
    AND 0FEH ;; (1) 最下位ビットをクリアする
    LD C,A   ;; (2) Cに保管する。
    RRA      ;; (3) A=C/4
    RRA      ;;
    ADD A,C  ;; (4) A=5/4*C
    RRA      ;; (5) A=5/8*C
    ADD A,C  ;; (6) A=13/8*C
    AND 0F0H ;; (7) あと4回回転命令を実行するが(回転命令のほうがシフト命令より効率的)、ここで下位ニブルをマスクして上位ニブルに回り込まないようにしておく
    RRA      ;; (8) A=13/16*C
    RRA      ;; (9) A=13/32*C
    LD C,A   ;; (10) 中間結果をあとで使うため保管する。
    RRA      ;; (11) A=13/64*C
    RRA      ;; (12) A=13/128*C
;;
;; 剰余を求める
;;
    LD H,A
    ADD A,C  ;; (13) (10)で保管したCをC利用する。C=A*4となので、これでA=A*5。
    CPL      ;; (14) ここ以降は前回と同様。A*10の2の補数を求める
    RLCA
    ADC A,B  ;; (15) B: 剰余
```
「バイナリ値をBCDに変換する(2)〜(5)」と比較すると、これの方法が一番シンプルでわかりやすく、一番早い。一方で、短さで言えば「バイナリ値をBCDに変換する(1)」が一番短い。
