---
title: バイナリ値をBCDに変換する(4)
author: Kazumasa
layout: post
tags: [Z80, Assembly Language, BCD]
description: Some notes about binary to BCD conversion
---
次は、[Z80での10の高速除算方法　[Z80]](https://piclabo.blog.ss-blog.jp/Z80_Division)から。重要なアイデアが2つある。1つ目は0.1を小数で表現する点だ。

0.1を2進数で書くと、
```
0.1=2^-4+2^-5+2^-8+2^-9+...
   =0b0.0001100110011...
```
のように循環小数になる。そこで、被除数をBとすると
```
B×0.1=B*(0b1.1)/16+B*(0b1.1)/16/16+...
      =B*(1.5/16+1.5/16/16+1.5/16/16/16...)
```
とかける。括弧内の和は、どこかで計算を打ち切ることになるが、そうすると、必ず0.1より小さな値となり、10の倍数のときに正しい商が求められなくなる。そこで1つ目の和で計算を打ち切り、被除数に1を加えることで補正を行う。下記のプログラムでは、最下位ビットを立てて被除数が偶数のときだけ1を加算している。

もう一つの重要なアイデアは上位と下位のニブルを反転したまま計算するところだ。
(補正後の)被除数を1.5倍したあとのビットパターンをabcd_efghとすると、1/16したときのビットパターンはabcd.efghとなる。これを更に1/16した値を加算すると、
```
   abcd.efgh
+)    0.abcd_efgh
```
と書ける。したがって、被除数を1.5/16したあとの整数部(abcd)に小数部(efgh+abcd)の桁上がりを加えたものが商になる。桁上がりが発生するかどうかは、abcd_efghとその上下ニブルを入れ替えたもの(efgh_abcd)を足したabcd_efgh+efgh_abcdが桁上がりが発生するかを見ればよい。
```
    ;;
    ;; 商を求める
    ;;
    LD      A,B     ;
    OR      1       ;  (1) 被除数補正しておく
    RRA             ;  (2) 被除数を1.5倍する
    ADC     A,B     ;      B×0b1.1
    LD      C,A     ;      →C=abcd_efgh
    RRCA            ;  (3) 右に4ビット回転(上下のニブルを交換)
    RRCA            ;      →A=efgh_abcd
    RRCA            ;
    RRCA            ;
    ADD     A,C     ;  (4) 回転前の値と加算する
    CCF             ;  (5) キャリーフラグを反転する。
                    ;      桁上がりが発生していれば、キャリーフラグは0、
                    ;      桁上がりが発生していなければ、キャリーフラグは1になる
    SBC A,C         ;  (6) A+CからCとキャリーフラグを引くので、
                    ;      Aの下位ニブルには商より1少ない値が入る
    INC A           ;  (7) 引きすぎているので1を加算
    AND     0FH     ;  (8) A: 商
    ;;
    ;; 剰余を求める(前回と同じなので省略)
    ;;
    LD      H,A
    ADD     A,A
    ADD     A,A
    ADD     A,H
    CPL
    RLCA
    ADC     A,B
    RET
```

(4)の結果、桁上がりが発生していれば、(5)でキャリーフラグを0にセットする。

(5)ではA+CからCを引いて、さらにキャリーの反転を引く。この時点でAは商より1少ない値になっているので、(6)で1を加算し、(7)で上位ニブルをマスクして商を求めている。

桁上がりが発生している場合、
```
   efgh_abcd
+) abcd_efgh
-) abcd_efgh
+)         1  ;; 最初の加算でのキャリーフラグの値
```
桁上がりが発生していない場合、
```
   efgh_abcd
+) abcd_efgh
-) abcd_efgh
+)         0  ;; 最初の加算でのキャリーフラグの値
```
を計算したいが、abcd_efghの減算とキャリーフラグの加算を同時に実行する命令はない。
そこでCCF命令でキャリーフラグを反転した後((5))、SBC命令でキャリーの反転を引き((6))、補正のために1を加算する((7))。つまり次のような計算を行う。
桁上がりが発生している場合、
```
   efgh_abcd
+) abcd_efgh  ;; ADD
-) abcd_efgh  ;; SBC
-)         0  ;; 最初の加算でのキャリーフラグの反転
+)         1  ;; INC
```
桁上がりが発生していない場合、
```
   efgh_abcd
+) abcd_efgh  ;; ADD
-) abcd_efgh  ;; SBC
-)         1  ;; 最初の加算でのキャリーフラグの反転
+)         1  ;; INC
```

次回は、このアイデアをyasuoka氏が使用した例について紹介する。
